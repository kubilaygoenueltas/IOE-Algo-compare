function out=orientation_estimation_ahrs_mkmc_fun_gpt(acc,gyro,fs,sigma_x,sigma_y)

%% construct error state Kalman function
  dT=1/fs;
  cOrientErrVar    = deg2rad(1)*deg2rad(1)*2000e-5; % var in init orientation error estim.
  cGyroBiasErrVar  = deg2rad(1)*deg2rad(1)*250e-3*0.1; % var in init gyro bias error estim
  cOrientGyroBiasErrVar = deg2rad(1)*deg2rad(1)*0; % covar orient -gyro bias error estim
  cAccErrVar       = 10e-5 * (9.81^2);  % var in linear accel drift error estim
  % set Q
  theta_w=cOrientErrVar*ones(1,3);
  b_w=cGyroBiasErrVar*ones(1,3);
  a_w=cAccErrVar*ones(1,3);
  
  w=[theta_w,b_w,a_w];
  Qw=diag(w);
  % set R
  k2=dT*dT;
  % gyroscopeDriftNoise
  beta=3.0462*10^(-13);
  % GyroscopeNoise
  yita =9.1385*10^(-5);
  %  AccelerometerNoise
  lamda=0.00019247;
  
  % LinearAccelerationNoise
  xi=0.0096236;
  
  %LinearAcclerationDecayFactor 
  nv=0.3;
  
  Ra= (lamda+xi+k2*(beta+yita))*eye(3);
  R=Ra;

  % set GyroOffset
  gyro_offset=zeros(1,3);
  % set linear acc prior
  linAccelPrior=zeros(1,3);
  linAccelPost=zeros(1,3);
  
  % set initial P_
  P_=Qw;
  
  % set the initial state vector
  Xe=zeros(12,1);
  
  bp = chol(P_,'lower') ;
  br = chol(R,'lower') ;
  
  len=length(acc);
  
  % Initialize yaw state and drift tracking variables
  psi_k = 0;              % Yaw angle estimate
  prev_psi_k = 0;         % Previous yaw estimate for drift correction
  yaw_drift_accumulator = 0; % Accumulate drift for correction


  
for i=1:len
   accr=acc(i,:);
   gyror=gyro(i,:);

   
   if(i==1)     % NED coordinate
   r_down = accr';
   r_east = [1;0;0]; % assume any direction?
   %r_east = [-24.6226; 397.6748; -552.3066];
   r_north = cross(r_east, r_down);
   
   r_down=r_down/norm(r_down);
   r_east=r_east/norm(r_east);
   r_north=r_north/norm(r_north);
   
   R_=[r_north,r_east,r_down];
   Q__ = quaternion(R_, 'rotmat', 'frame');
   end

   % without NED
   %if(i==1)
   %Q__ = quaternion([1 0 0 0]); % Identity quaternion (neutral orientation)
   %end

   % predict
   Q_delta=(gyror(1:3)-gyro_offset)*dT;
   Q_delta=quaternion(Q_delta,'rotvec');
   % Predict Quaternion Update using Gyroscope (Including Yaw Tracking)
    yaw_rate = gyror(3); % Gyro z-axis angular velocity
    psi_k = psi_k + yaw_rate * dT; % Integrate yaw
    
    % Ensure yaw is within [-pi, pi] range
    psi_k = wrapToPi(psi_k);
   Q_=Q__*Q_delta;
   if parts(Q_) < 0
      Q_ = -Q_;
   end
   %compare with ecompass command
   Rprior = rotmat(Q_, 'frame'); 
   % The Kalman filter measurement:
   linAccelPrior=nv*linAccelPost;
   % estimate gravity from acceleration
   gAccel=accr+linAccelPrior;
   g=Rprior(:,3)'*9.81;
   %g= [0 0 -9.81];          % Assume initial gravity direction without NED
   gdiffer=gAccel-g;
   % Earth's mag vec (uT) from gyro updates
   %magVecGyroMeas=(Rprior*pMagVec')';
   

   % Detect Low-Motion Phase (Assume Baby's Leg is Momentarily Stationary)
   if norm(gyror) < 0.05 && norm(accr) < 0.2 % Thresholds for rest detection
       yaw_drift = psi_k - prev_psi_k;
    
       % Apply a decay factor to slowly correct yaw drift
       psi_k = prev_psi_k + 0.01 * yaw_drift; % Small correction factor
    
       % Reset drift accumulator
       prev_psi_k = psi_k;
   end

   % Estimate Lateral Acceleration for Yaw Drift Correction
   lateral_accel = norm(gAccel(1:2)); % X-Y plane
   if lateral_accel < 0.2  % Low movement condition (assume stable heading)
        yaw_correction = atan2(gAccel(2), gAccel(1)) - atan2(g(2), g(1));
        psi_k = psi_k + 0.05 * yaw_correction;  % Apply a small correction factor
   end

   % Adaptive Drift Compensation
   motion_intensity = norm(gyror) + norm(accr); % Combined motion energy

   if motion_intensity > 0.5 % Active movement detected
       yaw_compensation = 0.02 * (psi_k - prev_psi_k); % Slow drift correction
   elseif motion_intensity < 0.1 % Low movement detected
       yaw_compensation = 0.05 * (psi_k - prev_psi_k); % Stronger correction
   else
       yaw_compensation = 0.03 * (psi_k - prev_psi_k);
   end

   % Apply the compensation
   psi_k = psi_k - yaw_compensation;


   % observer model
   k=dT;
   H=[0 g(3) -g(2) 0 -k*g(3) k*g(2) 1 0 0;
      -g(3) 0 g(1) k*g(3) 0 -k*g(1) 0 1 0;
      g(2) -g(1) 0 -k*g(2) k*g(1) 0 0 0 1];
    
    ze=gdiffer';

  %% this is MKMC part
  cnt=3;
  if(i>1)
  xee=zeros(1,9);
  THE=zeros(cnt,1);
  num=cnt;
  X_=zeros(9,1);
  
  while(num>0)
    
   bp = chol(P_,'lower') ;
   br = chol(R,'lower') ;
   if(num==cnt)
   X_tlast=X_; 
   else  
   X_tlast=X_t; 
   end
   dp= bp\X_;
   dr= br\ze;
   wp= bp\X_tlast;
   wr= br\H*X_tlast;
   ep=dp-wp;
   er=dr-wr;
   diax=exp(-ep.*ep./sigma_x');
   diay=exp(-er.*er./sigma_y');
    for k=1:9
        if(diax(k)<1e-8)
           diax(k)=1e-8;
        end
    end
    for k=1:3
        if(diay(k)<1e-8)
           diay(k)=1e-8;
        end
    end
    
    Cx=diag(diax);
    Cy=diag(diay);
    
    R_1=br/Cy*br';
    P_1=bp/Cx*bp';
    K_1=P_1*H'/(H*P_1*H'+R_1);

    X_t=X_+K_1*(ze); 
    num=num-1;
    thresh=norm(X_t-X_tlast)/(norm(X_tlast)+1e-3);
    if(num==1)
    xee=ep;
    end
    THE(cnt-num)=thresh;
    if(thresh<0.02)
        break;
    end
  end
  K=K_1;
  Xe=X_t;
  % Corrected error estimates
  
  else
  THE=zeros(cnt,1);
  xee=zeros(1,9);
  S=R+H*(P_)*H';
  % Kalman Gain
  K=(P_)*H'/S';
  % Updata a Posterior Error
  ze=gdiffer';
  end
  
    %  The else part correctly updates the orientation, gyroscope bias, and
    %  linear acceleration using only the accelerometer and gyroscope
  xe_post=K*ze; 
  % Error parts of xe_post
  orientErr = xe_post(1:3).';
  gyroOffsetErr = xe_post(4:6).';
  linAccelErr = xe_post(7:9).';
  

  % update posterior estimate
  qerr = conj(quaternion(orientErr, 'rotvec'));
  Q__=Q_*qerr;
  % Force rotation angle to be positive
  if parts(Q__) < 0
    Q__ = -Q__;
  end
  Q__=normalize(Q__);
  Rpost = rotmat(Q__, 'frame');
  % estimate linear acceleartion
  linAccelPost=linAccelPrior-linAccelErr;
  % estimate Gyroscope Offset
  gyro_offset=gyro_offset-gyroOffsetErr;
    
  P__=P_-K*(H*P_);
  
  % predict error estimate covariance for next iteration
  k=dT;
  Qw=[P__(1)+k^2*(P__(31)+beta+yita) 0 0 -k*(P__(31)+beta) 0 0 0 0 0;
     0 P__(11)+k^2*(P__(41)+beta+yita) 0 0 -k*(P__(41)+beta) 0 0 0 0;
     0 0 P__(21)+k^2*(P__(51)+beta+yita) 0 0 -k*(P__(51)+beta) 0 0 0;
     -k*(P__(31)+beta) 0 0 P__(31)+beta 0 0 0 0 0;
     0 -k*(P__(41)+beta) 0 0 P__(41)+beta 0 0 0 0;
     0 0 -k*(P__(51)+beta) 0 0 P__(51)+beta 0 0 0;
     0 0 0 0 0 0 nv^2*P__(61)+xi 0 0;
     0 0 0 0 0 0 0 nv^2*P__(71)+xi 0;
     0 0 0 0 0 0 0 0 nv^2*P__(81)+xi];
  
    % Update error covariance matrix 
    P_=Qw;
    % compute Augular Velocity
    %augVel(i,:)=gyror-gyro_offset;
    %output
    Quat(i,:)=Q__; 
    acc(i,:)=linAccelPost;
    offset(i,:)=gyro_offset;
    % change quaternion to eular 
   XEE(i,:)=xee;
   THRESH(i,:)=THE';
end

elu=eulerd(Quat,'YXZ','frame');
t=0:1/fs:1/fs*(len-1);

out.t=t;
out.Quat=Quat;
out.elu=elu;
out.acc=acc;
out.XEE=XEE;
out.offset=offset;
out.THRESH=THRESH;
end